[
  {
    "id": "ace-iam-001",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your development team needs to grant a group of developers the ability to view resources in a project but not modify them.",
    "question": "What is the Google-recommended approach to grant read-only access?",
    "options": [
      {
        "id": "A",
        "text": "Grant the Viewer role to each individual developer"
      },
      {
        "id": "B",
        "text": "Create a Google Group, add developers to it, and grant the Viewer role to the group"
      },
      {
        "id": "C",
        "text": "Grant the Editor role but train developers not to make changes"
      },
      {
        "id": "D",
        "text": "Create a custom role with only list permissions for each service"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "Google recommends using groups instead of granting roles to individual users. This simplifies permission management, makes it easier to onboard/offboard users, and follows the principle of centralized access control. The Viewer role provides read-only access across all resources.",
      "incorrect": {
        "A": "Granting roles to individual users is harder to manage at scale. Adding/removing permissions requires updating each user individually.",
        "C": "Granting more permissions than needed violates the principle of least privilege and relies on user behavior rather than technical controls.",
        "D": "While custom roles can work, the predefined Viewer role already provides appropriate read-only access and is simpler to manage."
      }
    },
    "keyConceptName": "IAM Best Practice - Use Groups",
    "keyConcept": "Always use Google Groups for granting permissions instead of individual users. This simplifies management, improves security, and makes it easier to audit access.",
    "tags": ["iam-best-practices", "groups", "viewer-role", "least-privilege"],
    "examPatternKeywords": ["google-recommended", "best practice", "read-only"],
    "relatedQuestionIds": ["ace-iam-008", "ace-iam-015"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/best-practices"
  },
  {
    "id": "ace-iam-002",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-select",
    "scenario": "You need to configure a Compute Engine VM to access Cloud Storage buckets and Cloud SQL databases without using service account keys.",
    "question": "Which IAM best practices should you follow? (Select 3)",
    "options": [
      {
        "id": "A",
        "text": "Attach a service account to the VM instance"
      },
      {
        "id": "B",
        "text": "Generate and download service account keys to the VM"
      },
      {
        "id": "C",
        "text": "Grant the service account minimum required permissions"
      },
      {
        "id": "D",
        "text": "Use the VM's default service account with Editor role"
      },
      {
        "id": "E",
        "text": "Create a custom service account with specific roles"
      }
    ],
    "correctAnswer": ["A", "C", "E"],
    "explanation": {
      "correct": "Attach a custom service account to the VM (A), grant it only the minimum required permissions following least privilege (C), and create a custom service account rather than using defaults (E). This avoids service account keys entirely by using workload identity.",
      "incorrect": {
        "B": "Service account keys should be avoided whenever possible. VMs can authenticate using attached service accounts without keys.",
        "D": "The default service account has Editor role which violates least privilege. Always create custom service accounts with minimal permissions."
      }
    },
    "keyConceptName": "Service Account Best Practices",
    "keyConcept": "Never use service account keys when workload identity is available. Attach service accounts directly to VMs and grant minimal permissions using custom service accounts, not defaults.",
    "tags": [
      "service-accounts",
      "least-privilege",
      "workload-identity",
      "iam-best-practices"
    ],
    "examPatternKeywords": [
      "best practice",
      "google-recommended",
      "without keys"
    ],
    "relatedQuestionIds": ["ace-iam-012", "ace-iam-023"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/best-practices-service-accounts"
  },

  {
    "id": "ace-iam-003",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your organization has hired external auditors who need read-only access to view Cloud Logging data and BigQuery datasets, but should not be able to modify any resources or see data access logs.",
    "question": "Which predefined role should you grant?",
    "options": [
      {
        "id": "A",
        "text": "Viewer role at the project level"
      },
      {
        "id": "B",
        "text": "Logging Viewer and BigQuery Data Viewer roles"
      },
      {
        "id": "C",
        "text": "Security Reviewer role at the project level"
      },
      {
        "id": "D",
        "text": "Browser role at the organization level"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "Grant specific roles for each service: Logging Viewer for Cloud Logging access and BigQuery Data Viewer for BigQuery datasets. This follows the principle of least privilege by granting only the necessary permissions without broader project access.",
      "incorrect": {
        "A": "The Viewer role provides read access to all resources in the project, which is overly broad. It grants more permissions than needed for the specific audit requirements.",
        "C": "Security Reviewer is designed for security-related resources and policies, not for general logging and data access. It doesn't provide the specific permissions needed for logs and BigQuery.",
        "D": "The Browser role only allows browsing the resource hierarchy without viewing resource data. Auditors need to actually read logs and datasets, not just browse the project structure."
      }
    },
    "keyConceptName": "Service-Specific IAM Roles",
    "keyConcept": "Use service-specific predefined roles (like Logging Viewer, BigQuery Data Viewer) instead of broad project-level roles when users need access to specific services. This implements least privilege by granting only necessary permissions.",
    "tags": ["iam-roles", "least-privilege", "predefined-roles", "auditing"],
    "examPatternKeywords": ["read-only", "should not modify", "which role"],
    "relatedQuestionIds": ["ace-iam-001", "ace-iam-008"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/understanding-roles"
  },
  {
    "id": "ace-iam-004",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-select",
    "scenario": "You need to set up a service account for a Cloud Function that will read from Cloud Storage, write to BigQuery, and send messages to Pub/Sub. You want to follow Google-recommended security practices. What should you do? (Select 3)",
    "question": "Which configurations follow least privilege and security best practices?",
    "options": [
      {
        "id": "A",
        "text": "Create a custom service account specifically for this Cloud Function"
      },
      {
        "id": "B",
        "text": "Grant Storage Object Viewer, BigQuery Data Editor, and Pub/Sub Publisher roles"
      },
      {
        "id": "C",
        "text": "Use the default App Engine service account"
      },
      {
        "id": "D",
        "text": "Grant roles at the resource level (bucket, dataset) rather than project level"
      },
      {
        "id": "E",
        "text": "Download and store service account keys for authentication"
      }
    ],
    "correctAnswer": ["A", "B", "D"],
    "explanation": {
      "correct": "Create a custom service account for this specific function (A), grant only the minimum required permissions for each service (B), and scope permissions to specific resources rather than project-wide (D). This implements defense in depth with least privilege.",
      "incorrect": {
        "C": "Default service accounts often have excessive permissions and are shared across resources. Always create custom service accounts with minimal permissions for each workload.",
        "E": "Service account keys should be avoided. Cloud Functions automatically use attached service accounts for authentication without keys, leveraging workload identity."
      }
    },
    "keyConceptName": "Service Account Security Best Practices",
    "keyConcept": "Create custom service accounts per workload, grant minimum required permissions using specific predefined roles, scope permissions to resources not projects, and avoid service account keys by using workload identity. This implements least privilege and defense in depth.",
    "tags": [
      "service-accounts",
      "least-privilege",
      "security-best-practices",
      "workload-identity"
    ],
    "examPatternKeywords": [
      "security practices",
      "least privilege",
      "should you do"
    ],
    "relatedQuestionIds": ["ace-iam-002", "ace-iam-009"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/best-practices-service-accounts"
  },
  {
    "id": "ace-iam-005",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "A developer accidentally deleted a critical IAM policy binding that granted the operations team access to production resources. You need to identify who made the change and when.",
    "question": "What should you do?",
    "options": [
      {
        "id": "A",
        "text": "Check Cloud Logging Admin Activity logs and filter for setIamPolicy operations"
      },
      {
        "id": "B",
        "text": "Check Cloud Monitoring metrics for IAM changes"
      },
      {
        "id": "C",
        "text": "Review the IAM policy version history in the console"
      },
      {
        "id": "D",
        "text": "Use Cloud Asset Inventory to view current IAM policies"
      }
    ],
    "correctAnswer": ["A"],
    "explanation": {
      "correct": "Admin Activity logs record all IAM policy changes including who made them and when. Filter for 'setIamPolicy' operations to find the deletion. These logs are automatically enabled and retained, providing a complete audit trail of permission changes.",
      "incorrect": {
        "B": "Cloud Monitoring metrics track resource usage and performance, not detailed audit information about who made specific configuration changes.",
        "C": "IAM policies don't have built-in version history in the console. The audit trail exists in Cloud Logging, not as versioned policy snapshots.",
        "D": "Cloud Asset Inventory shows current state and historical snapshots of resources but isn't optimized for identifying specific change events or who made them. Admin Activity logs are purpose-built for this."
      }
    },
    "keyConceptName": "IAM Audit Logging",
    "keyConcept": "Admin Activity logs automatically record all IAM policy changes with full audit details (who, what, when). Use Cloud Logging to query setIamPolicy operations for investigating permission changes. These logs are always enabled and retained for 400 days.",
    "tags": ["iam", "audit-logs", "cloud-logging", "change-tracking"],
    "examPatternKeywords": ["identify who", "made the change", "when"],
    "relatedQuestionIds": ["ace-iam-013", "ace-monitoring-003"],
    "officialDocsUrl": "https://cloud.google.com/logging/docs/audit"
  },
  {
    "id": "ace-iam-006",
    "domain": "iam",
    "difficulty": "easy",
    "type": "multiple-choice",
    "scenario": "Your team needs to grant temporary elevated access to a contractor for a 2-week project. After the project, access should automatically be revoked.",
    "question": "What IAM feature should you use?",
    "options": [
      {
        "id": "A",
        "text": "Create a custom role with an expiration date"
      },
      {
        "id": "B",
        "text": "Grant the role with a conditional IAM binding using expiration time"
      },
      {
        "id": "C",
        "text": "Set a calendar reminder to manually revoke access"
      },
      {
        "id": "D",
        "text": "Use a service account with automatic rotation"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "IAM conditions allow you to add expiration times to role bindings. Use the request.time < timestamp() condition to automatically revoke access after the specified date. This ensures access is automatically removed without manual intervention.",
      "incorrect": {
        "A": "Custom roles define permissions but don't have expiration capabilities. Role bindings, not roles themselves, can have time-based conditions.",
        "C": "Manual processes are error-prone and don't scale. IAM conditions provide automated, reliable access expiration without human intervention.",
        "D": "Service accounts are for applications, not user access. Rotation refers to key rotation, not access duration. This doesn't address the temporary user access requirement."
      }
    },
    "keyConceptName": "IAM Conditional Bindings",
    "keyConcept": "Use IAM conditions to add context-aware access control including time-based expiration (request.time), resource attributes, and IP ranges. Conditions automatically enforce access policies without manual intervention, ideal for temporary access scenarios.",
    "tags": [
      "iam-conditions",
      "temporary-access",
      "time-based-access",
      "automation"
    ],
    "examPatternKeywords": [
      "temporary",
      "automatically revoked",
      "what feature"
    ],
    "relatedQuestionIds": ["ace-iam-012", "ace-iam-014"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/conditions-overview"
  },
  {
    "id": "ace-iam-007",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "You need to grant a service account from Project A permission to access resources in Project B. The service account needs to list and read Compute Engine instances.",
    "question": "What should you do?",
    "options": [
      {
        "id": "A",
        "text": "Export the service account key from Project A and import it to Project B"
      },
      {
        "id": "B",
        "text": "Grant the service account from Project A the Compute Viewer role in Project B"
      },
      {
        "id": "C",
        "text": "Create a new service account in Project B and use impersonation"
      },
      {
        "id": "D",
        "text": "Set up VPC peering between Project A and Project B"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "Service accounts can be granted IAM roles in any project within the same organization. Simply add the service account from Project A as a member in Project B's IAM policy with the Compute Viewer role. No key export or additional configuration needed.",
      "incorrect": {
        "A": "Service account keys don't need to be exported/imported for cross-project access. You can directly grant IAM permissions to service accounts from other projects.",
        "C": "Impersonation adds unnecessary complexity. Direct role assignment is simpler and follows the principle of least privilege when you only need specific permissions.",
        "D": "VPC peering is for network connectivity, not IAM permissions. It doesn't grant service accounts permission to access resources in other projects."
      }
    },
    "keyConceptName": "Cross-Project IAM",
    "keyConcept": "Service accounts can be granted roles in any project within an organization. Use the full service account email (sa@project.iam.gserviceaccount.com) when adding it to IAM policies in other projects. This enables secure cross-project resource access without keys.",
    "tags": [
      "service-accounts",
      "cross-project",
      "iam-permissions",
      "resource-access"
    ],
    "examPatternKeywords": ["project A", "access resources", "project B"],
    "relatedQuestionIds": ["ace-iam-004", "ace-iam-010"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/granting-changing-revoking-access"
  },
  {
    "id": "ace-iam-008",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-choice",
    "scenario": "Your company requires that all production resources must be managed only by users with corporate email addresses (@company.com). You need to enforce this policy across all projects in your organization.",
    "question": "What should you implement?",
    "options": [
      {
        "id": "A",
        "text": "Create a custom IAM role that checks email domain"
      },
      {
        "id": "B",
        "text": "Use Organization Policy with domain restriction constraint"
      },
      {
        "id": "C",
        "text": "Set up Cloud Identity to only allow corporate accounts"
      },
      {
        "id": "D",
        "text": "Use IAM conditions on all role bindings to check email domain"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "Organization Policies provide centralized controls across an entire organization. The 'iam.allowedPolicyMemberDomains' constraint restricts which domains can be granted IAM roles, automatically enforcing the policy on all projects and preventing non-corporate accounts from being added.",
      "incorrect": {
        "A": "Custom IAM roles define permissions, not identity requirements. They can't enforce domain restrictions on who can be granted access.",
        "C": "Cloud Identity manages user identities but doesn't enforce which identities can be granted permissions in specific projects. You need Organization Policy for enforcement.",
        "D": "While IAM conditions could technically check domains, applying them to every role binding doesn't scale and is error-prone. Organization Policy provides centralized, foolproof enforcement."
      }
    },
    "keyConceptName": "Organization Policy Constraints",
    "keyConcept": "Organization Policies enforce governance rules across all resources in an organization or folder. The iam.allowedPolicyMemberDomains constraint restricts which domains can be granted IAM roles, preventing external accounts from accessing resources. This provides centralized security enforcement.",
    "tags": [
      "organization-policy",
      "domain-restriction",
      "governance",
      "security"
    ],
    "examPatternKeywords": [
      "enforce policy",
      "across all projects",
      "organization"
    ],
    "relatedQuestionIds": ["ace-iam-003", "ace-iam-015"],
    "officialDocsUrl": "https://cloud.google.com/resource-manager/docs/organization-policy/restricting-domains"
  },
  {
    "id": "ace-iam-009",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "A Compute Engine instance needs to access Cloud Storage buckets. The application team wants to use Application Default Credentials without managing keys.",
    "question": "How should you configure authentication?",
    "options": [
      {
        "id": "A",
        "text": "Generate service account keys and store them in the instance metadata"
      },
      {
        "id": "B",
        "text": "Attach a service account with appropriate Storage permissions to the instance"
      },
      {
        "id": "C",
        "text": "Configure OAuth 2.0 credentials in the application code"
      },
      {
        "id": "D",
        "text": "Use gcloud auth application-default login on the instance"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "Attach a service account with Storage Object Viewer or appropriate roles to the Compute Engine instance. The instance automatically uses this identity for Application Default Credentials, providing seamless authentication without managing keys.",
      "incorrect": {
        "A": "Service account keys should never be stored in metadata. This creates security risks. Attached service accounts provide authentication without keys.",
        "C": "OAuth 2.0 credentials are for user authentication, not service-to-service authentication. Service accounts are the proper identity for applications.",
        "D": "The 'gcloud auth application-default login' command is for local development with user credentials. Production instances should use attached service accounts, not user credentials."
      }
    },
    "keyConceptName": "Application Default Credentials with Service Accounts",
    "keyConcept": "Compute Engine instances use attached service accounts for Application Default Credentials automatically. Applications using GCP client libraries automatically discover and use these credentials without code changes or key management. This is the recommended pattern for workload identity.",
    "tags": [
      "service-accounts",
      "application-default-credentials",
      "workload-identity",
      "compute-engine"
    ],
    "examPatternKeywords": [
      "without managing keys",
      "application default credentials",
      "how configure"
    ],
    "relatedQuestionIds": ["ace-iam-002", "ace-iam-004"],
    "officialDocsUrl": "https://cloud.google.com/docs/authentication/application-default-credentials"
  },
  {
    "id": "ace-iam-010",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-select",
    "scenario": "Your organization uses Cloud Identity with federated authentication from Active Directory. You need to grant permissions to on-premises users who don't have Google accounts. What should you implement? (Select 3)",
    "question": "Which steps properly configure federated identity access?",
    "options": [
      {
        "id": "A",
        "text": "Set up SAML SSO between Active Directory and Cloud Identity"
      },
      {
        "id": "B",
        "text": "Use Google Cloud Directory Sync to synchronize users to Cloud Identity"
      },
      {
        "id": "C",
        "text": "Grant IAM roles to the Cloud Identity user accounts or groups"
      },
      {
        "id": "D",
        "text": "Create service accounts for each on-premises user"
      },
      {
        "id": "E",
        "text": "Export user credentials from Active Directory to Secret Manager"
      }
    ],
    "correctAnswer": ["A", "B", "C"],
    "explanation": {
      "correct": "SAML SSO enables federated login (A), Directory Sync creates Cloud Identity accounts from AD users (B), and IAM roles grant these identities permissions (C). This complete solution allows on-premises users to authenticate with AD credentials and access GCP resources.",
      "incorrect": {
        "D": "Service accounts are for applications and services, not individual users. Creating service accounts per user violates best practices and makes auditing difficult.",
        "E": "Never export user credentials from identity providers. Federation allows users to authenticate with their existing credentials without storing them in GCP."
      }
    },
    "keyConceptName": "Federated Identity with Cloud Identity",
    "keyConcept": "Cloud Identity supports federated authentication via SAML SSO with external identity providers. Use Google Cloud Directory Sync to synchronize users, SAML for authentication, and IAM for authorization. Users authenticate with existing credentials while accessing GCP resources.",
    "tags": ["cloud-identity", "federation", "saml-sso", "directory-sync"],
    "examPatternKeywords": [
      "federated authentication",
      "don't have google accounts",
      "active directory"
    ],
    "relatedQuestionIds": ["ace-iam-001", "ace-iam-015"],
    "officialDocsUrl": "https://cloud.google.com/architecture/identity/federating-gcp-with-active-directory-introduction"
  },
  {
    "id": "ace-iam-011",
    "domain": "iam",
    "difficulty": "easy",
    "type": "multiple-choice",
    "scenario": "You need to view all IAM role bindings for a specific project to understand who has access to what resources.",
    "question": "Which gcloud command should you use?",
    "options": [
      {
        "id": "A",
        "text": "gcloud iam roles list --project=PROJECT_ID"
      },
      {
        "id": "B",
        "text": "gcloud projects get-iam-policy PROJECT_ID"
      },
      {
        "id": "C",
        "text": "gcloud iam service-accounts list --project=PROJECT_ID"
      },
      {
        "id": "D",
        "text": "gcloud projects describe PROJECT_ID"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "The command 'gcloud projects get-iam-policy PROJECT_ID' returns the complete IAM policy for a project, showing all members, their roles, and any conditions. This provides a comprehensive view of all access granted at the project level.",
      "incorrect": {
        "A": "This command lists available IAM roles (predefined and custom), not the role bindings showing who has what access in the project.",
        "C": "This lists service accounts in the project but doesn't show role bindings or which principals have access to resources.",
        "D": "The describe command shows project metadata like project number, creation time, and labels, but not IAM policy bindings."
      }
    },
    "keyConceptName": "IAM Policy Inspection",
    "keyConcept": "Use 'gcloud projects get-iam-policy' to view complete IAM policies including all role bindings, members, and conditions. For resources like buckets or datasets, use similar patterns: 'gsutil iam get gs://BUCKET' or 'bq show --format=prettyjson DATASET'.",
    "tags": ["iam-policy", "gcloud", "access-review", "commands"],
    "examPatternKeywords": ["view all", "role bindings", "who has access"],
    "relatedQuestionIds": ["ace-iam-005", "ace-dev-004"],
    "officialDocsUrl": "https://cloud.google.com/sdk/gcloud/reference/projects/get-iam-policy"
  },
  {
    "id": "ace-iam-012",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your security team requires that production database access is only allowed from the corporate network IP range (203.0.113.0/24). You need to enforce this at the IAM level.",
    "question": "What IAM feature should you use?",
    "options": [
      {
        "id": "A",
        "text": "Create a custom IAM role that checks IP addresses"
      },
      {
        "id": "B",
        "text": "Use IAM conditions with the origin.ip attribute"
      },
      {
        "id": "C",
        "text": "Configure VPC firewall rules"
      },
      {
        "id": "D",
        "text": "Set up Cloud Armor security policies"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "IAM conditions support IP-based access control using the origin.ip attribute in the conditional expression. Add conditions like 'origin.ip in ['203.0.113.0/24']' to role bindings to restrict access based on source IP, enforcing network-based access control at the IAM level.",
      "incorrect": {
        "A": "Custom IAM roles define permissions but cannot evaluate runtime context like IP addresses. IAM conditions provide context-aware access control.",
        "C": "VPC firewall rules control network traffic but don't integrate with IAM for permission evaluation. They're complementary but serve different purposes (network vs. identity).",
        "D": "Cloud Armor protects against DDoS and web attacks at the load balancer level. It doesn't integrate with IAM for permission decisions."
      }
    },
    "keyConceptName": "IAM Conditions for Network-Based Access",
    "keyConcept": "IAM conditions support context-aware access control including IP-based restrictions using origin.ip. Combine with time-based (request.time) and resource-based conditions for comprehensive zero-trust access policies. Conditions apply to all API calls, enforcing network requirements.",
    "tags": [
      "iam-conditions",
      "ip-restrictions",
      "network-security",
      "context-aware"
    ],
    "examPatternKeywords": [
      "only allowed from",
      "IP range",
      "enforce at IAM level"
    ],
    "relatedQuestionIds": ["ace-iam-006", "ace-iam-014"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/conditions-attribute-reference"
  },
  {
    "id": "ace-iam-013",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-choice",
    "scenario": "Your compliance team needs to receive alerts whenever IAM policies are modified in production projects. The alerts should include details about what changed and who made the change.",
    "question": "What monitoring solution should you implement?",
    "options": [
      {
        "id": "A",
        "text": "Create a log sink to BigQuery and query for changes daily"
      },
      {
        "id": "B",
        "text": "Create a log-based metric for setIamPolicy operations and configure alerting"
      },
      {
        "id": "C",
        "text": "Enable Data Access logs for all services"
      },
      {
        "id": "D",
        "text": "Use Cloud Asset Inventory to track policy changes"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "Create a log-based metric filtering Admin Activity logs for 'setIamPolicy' operations, then configure Cloud Monitoring alerting policies on this metric. Alerts trigger in real-time when IAM changes occur, including full details from the log entry (who, what, when).",
      "incorrect": {
        "A": "While log sinks preserve data for analysis, querying daily doesn't provide real-time alerts. The compliance team needs immediate notification, not batch processing.",
        "C": "Data Access logs record data read/write operations, not IAM policy changes. Admin Activity logs (already enabled) contain policy modifications.",
        "D": "Cloud Asset Inventory provides point-in-time snapshots and change history but doesn't send real-time alerts. It's better for investigations than proactive monitoring."
      }
    },
    "keyConceptName": "IAM Change Alerting",
    "keyConcept": "Monitor IAM changes using log-based metrics on Admin Activity logs filtered for setIamPolicy operations. Configure Cloud Monitoring alerting policies to send notifications (email, SMS, PagerDuty) in real-time. This provides proactive detection of permission changes for compliance and security.",
    "tags": ["iam-monitoring", "log-based-metrics", "alerting", "compliance"],
    "examPatternKeywords": [
      "receive alerts",
      "IAM policies modified",
      "should implement"
    ],
    "relatedQuestionIds": ["ace-iam-005", "ace-monitoring-004"],
    "officialDocsUrl": "https://cloud.google.com/logging/docs/logs-based-metrics"
  },
  {
    "id": "ace-iam-014",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your application needs access to a Cloud SQL database, but you want to ensure the service account can only connect during business hours (9 AM - 5 PM UTC) on weekdays.",
    "question": "How should you implement this restriction?",
    "options": [
      {
        "id": "A",
        "text": "Configure Cloud SQL maintenance windows"
      },
      {
        "id": "B",
        "text": "Add an IAM condition with time-based constraints to the service account's role binding"
      },
      {
        "id": "C",
        "text": "Use Cloud Scheduler to enable/disable the service account"
      },
      {
        "id": "D",
        "text": "Configure VPC firewall rules with time-based policies"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "IAM conditions support time-based access control using request.time expressions. Create a condition like 'request.time.getHours() >= 9 && request.time.getHours() < 17 && request.time.getDayOfWeek() >= 1 && request.time.getDayOfWeek() <= 5' to restrict access to business hours.",
      "incorrect": {
        "A": "Maintenance windows control when Cloud SQL performs updates, not when applications can connect. This doesn't restrict access based on time.",
        "C": "Enabling/disabling service accounts isn't supported. Even if it were, this would require complex scheduling and doesn't provide granular time-based control.",
        "D": "VPC firewall rules control network traffic but don't support time-based policies and don't integrate with IAM for authentication decisions."
      }
    },
    "keyConceptName": "Time-Based IAM Conditions",
    "keyConcept": "IAM conditions support temporal access control using request.time functions (getHours, getDayOfWeek, etc.). This enables business-hours-only access, temporary permissions, or scheduled access patterns. Conditions evaluate on every API call, providing real-time enforcement.",
    "tags": [
      "iam-conditions",
      "time-based-access",
      "temporal-security",
      "access-control"
    ],
    "examPatternKeywords": [
      "only during",
      "business hours",
      "time restriction"
    ],
    "relatedQuestionIds": ["ace-iam-006", "ace-iam-012"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/conditions-overview"
  },
  {
    "id": "ace-iam-015",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-select",
    "scenario": "Your organization is implementing a security hardening initiative. You need to ensure that no one can accidentally grant the Owner role to external users or service accounts from outside your organization. What should you configure? (Select 3)",
    "question": "Which Organization Policies and configurations enforce this security requirement?",
    "options": [
      {
        "id": "A",
        "text": "Set iam.allowedPolicyMemberDomains to restrict member domains"
      },
      {
        "id": "B",
        "text": "Enable iam.disableServiceAccountKeyCreation constraint"
      },
      {
        "id": "C",
        "text": "Use iam.allowedPolicyMemberDomains with allowAll set to false"
      },
      {
        "id": "D",
        "text": "Configure custom roles without the Owner permissions"
      },
      {
        "id": "E",
        "text": "Apply the policy at the organization level to enforce across all projects"
      }
    ],
    "correctAnswer": ["A", "C", "E"],
    "explanation": {
      "correct": "The iam.allowedPolicyMemberDomains constraint (A) restricts which domains can receive IAM roles. Setting allowAll to false with your domain listed (C) prevents external accounts. Applying at the organization level (E) ensures consistent enforcement across all resources.",
      "incorrect": {
        "B": "Disabling service account key creation is good security practice but doesn't prevent granting Owner role to external accounts. It addresses key management, not role assignment.",
        "D": "Creating custom roles doesn't prevent use of predefined Owner role. Organization Policy constraints are needed to restrict which principals can be granted any role."
      }
    },
    "keyConceptName": "IAM Organization Policy Enforcement",
    "keyConcept": "Organization Policies enforce IAM restrictions across an organization or folder hierarchy. Use iam.allowedPolicyMemberDomains to whitelist domains that can receive roles, preventing external access. Apply at organization level for inheritance, with options for folder/project-level exceptions.",
    "tags": [
      "organization-policy",
      "iam-security",
      "domain-restriction",
      "governance"
    ],
    "examPatternKeywords": [
      "ensure no one can",
      "external users",
      "organization"
    ],
    "relatedQuestionIds": ["ace-iam-008", "ace-iam-010"],
    "officialDocsUrl": "https://cloud.google.com/resource-manager/docs/organization-policy/org-policy-constraints"
  },

  {
    "id": "ace-iam-016",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your organization has a strict security policy requiring that all Compute Engine instances in the 'Development' project cannot use the `Editor` role. An administrator mistakenly grants the `roles/editor` role to a group at the **Folder** level, which contains the 'Development' project. You need to enforce the original policy regardless of the Folder-level binding.",
    "question": "What is the most effective way to prevent the `Editor` role from being active in the 'Development' project while preserving the Folder-level role for other projects?",
    "options": [
      {
        "id": "A",
        "text": "Remove the `Editor` role from the group at the Folder level."
      },
      {
        "id": "B",
        "text": "Grant the `Viewer` role to the group at the Project level, which will override the Folder-level role."
      },
      {
        "id": "C",
        "text": "Use an **IAM Deny Policy** at the Project level to explicitly block the `compute.instances.create` permission for the group."
      },
      {
        "id": "D",
        "text": "Grant a Custom Role at the Project level that excludes the `compute.instances.create` permission."
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "IAM policies are additive, meaning roles granted at a higher level (Folder) are inherited. To explicitly *revoke* a permission or role that has been inherited, you must use an **IAM Deny Policy**. This policy type allows you to define a set of permissions that principal identities are explicitly denied, overriding any inherited allow policies.",
      "incorrect": {
        "A": "This would remove the role for *all* projects in the Folder, which violates the requirement to preserve it for others.",
        "B": "Granting a less permissive role (Viewer) at a lower level does not override a more permissive inherited role (Editor). IAM permissions are additive.",
        "D": "A custom role only grants permissions; it cannot override or deny permissions granted by an inherited role like Editor."
      }
    },
    "keyConceptName": "IAM Deny Policy and Inheritance",
    "keyConcept": "IAM policies are inherited hierarchically. To block an inherited permission or role binding, Google recommends using an **IAM Deny Policy**. This allows for explicit denial of access, which takes precedence over any inherited 'allow' policies.",
    "tags": ["iam", "hierarchy", "deny-policy", "least-privilege", "security"],
    "examPatternKeywords": [
      "enforce the original policy regardless of",
      "prevent the Editor role from being active",
      "preserve the Folder-level role"
    ],
    "relatedQuestionIds": ["ace-iam-007", "ace-iam-027"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/deny-policies-overview"
  },
  {
    "id": "ace-iam-017",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-select",
    "scenario": "You have a Compute Engine application that requires access to a Cloud Storage bucket. For compliance reasons, you must avoid long-lived credentials and ensure credentials cannot be exfiltrated from the VM.",
    "question": "What two recommended best practices should you follow for configuring the application's service account to meet these security requirements? (Select TWO)",
    "options": [
      {
        "id": "A",
        "text": "Download the service account key and use it to authenticate the application directly."
      },
      {
        "id": "B",
        "text": "Attach a custom Google-managed Service Account with the minimum required Storage role to the VM instance."
      },
      {
        "id": "C",
        "text": "Use **IAM Deny Policies** to block the `iam.serviceAccountKeys.create` permission for all developers in the project."
      },
      {
        "id": "D",
        "text": "Grant the `roles/owner` role to the default Compute Engine service account."
      }
    ],
    "correctAnswer": ["B", "C"],
    "explanation": {
      "correct": "Best practices dictate avoiding service account keys (long-lived credentials) and instead using the **attached service account** (B) for authentication, which provides short-lived credentials via the metadata server. Furthermore, to enforce the policy against key creation, you should use an **IAM Deny Policy** (C) to prevent the creation of new keys, thus ensuring compliance against long-lived credentials.",
      "incorrect": {
        "A": "Downloading and using a service account key creates a long-lived, exfiltratable credential, violating security requirements.",
        "D": "Granting the Owner role violates the principle of **least privilege**. You should use a custom service account with only the necessary Storage role."
      }
    },
    "keyConceptName": "Service Account Key Security",
    "keyConcept": "For workloads on GCP, always use the attached service account to authenticate and gain short-lived credentials via the metadata server. Avoid service account keys. Use IAM Deny policies to enforce this by preventing the creation of new keys.",
    "tags": [
      "iam",
      "service-accounts",
      "least-privilege",
      "best-practices",
      "multiple-select"
    ],
    "examPatternKeywords": [
      "avoid long-lived credentials",
      "cannot be exfiltrated",
      "recommended best practices"
    ],
    "relatedQuestionIds": ["ace-iam-009", "ace-iam-016"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/best-practices-service-accounts"
  },
  {
    "id": "ace-iam-018",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "A new compliance requirement states that a specific group of auditors must have read-only access to Cloud Storage buckets and the ability to view all BigQuery datasets, but *no* other permissions. The existing predefined roles are too permissive.",
    "question": "Which IAM solution should you use to grant the required specific set of permissions while adhering to the principle of least privilege?",
    "options": [
      {
        "id": "A",
        "text": "Grant the group the `Storage Object Viewer` and `BigQuery Data Viewer` predefined roles."
      },
      {
        "id": "B",
        "text": "Grant the group the Project-level `Viewer` primitive role."
      },
      {
        "id": "C",
        "text": "Create a **Custom Role** containing only the `storage.objects.list`, `storage.objects.get`, and all necessary `bigquery.datasets.get` and `bigquery.tables.list` permissions, and grant this custom role to the group."
      },
      {
        "id": "D",
        "text": "Grant the `Organization Administrator` role at the Project level."
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "When predefined roles are too permissive or when you need a combination of permissions that spans multiple services (like Storage and BigQuery) in a precise, least-privilege manner, the correct solution is to create a **Custom Role**. This role is built with the exact minimal set of required permissions.",
      "incorrect": {
        "A": "While these roles are good, they might contain more permissions than the auditor needs, and the question implies a need for a single, consolidated role based on the specific scenario.",
        "B": "The `Viewer` primitive role (and even the predefined `Viewer` role) grants read access to *all* resources in the project, which is more permissive than requested.",
        "D": "Organization Administrator is a highly privileged role and should never be used for simple auditing tasks, especially at the project level."
      }
    },
    "keyConceptName": "IAM Custom Roles",
    "keyConcept": "Custom Roles are user-defined roles that allow you to bundle specific permissions to meet fine-grained access requirements. They are used when predefined roles are too permissive, ensuring adherence to the principle of least privilege.",
    "tags": ["iam", "custom-roles", "least-privilege", "security"],
    "examPatternKeywords": [
      "required specific set of permissions",
      "adhering to the principle of least privilege",
      "predefined roles are too permissive"
    ],
    "relatedQuestionIds": ["ace-iam-004"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/creating-custom-roles"
  },
  {
    "id": "ace-iam-019",
    "domain": "iam",
    "difficulty": "easy",
    "type": "multiple-choice",
    "scenario": "A junior developer accidentally granted the **Project Editor** role to a new intern. The Project Editor role grants broad permissions across most services and is considered less granular than modern, predefined roles.",
    "question": "Which category of IAM role does the **Project Editor** role belong to?",
    "options": [
      {
        "id": "A",
        "text": "Predefined role"
      },
      {
        "id": "B",
        "text": "Custom role"
      },
      {
        "id": "C",
        "text": "Resource-level role"
      },
      {
        "id": "D",
        "text": "Primitive role"
      }
    ],
    "correctAnswer": ["D"],
    "explanation": {
      "correct": "The **Project Editor** (`roles/editor`), **Project Viewer** (`roles/viewer`), and **Project Owner** (`roles/owner`) roles are the three original **Primitive roles** (or Basic roles) in Google Cloud. They are project-wide, highly permissive, and generally discouraged in favor of more granular predefined roles.",
      "incorrect": {
        "A": "Predefined roles are granular, service-specific roles (e.g., `compute.admin`).",
        "B": "Custom roles are created by the user with a specific set of permissions.",
        "C": "Resource-level refers to where the role is applied, not the role category itself (though primitive roles are project-level by nature)."
      }
    },
    "keyConceptName": "IAM Primitive Roles",
    "keyConcept": "Primitive roles (Owner, Editor, Viewer) are the three legacy, highly-permissive roles that apply broadly across a project. They are officially discouraged for production use in favor of granular Predefined or Custom roles.",
    "tags": ["iam", "roles", "primitive-roles", "basic-roles"],
    "examPatternKeywords": ["Project Editor role", "category of IAM role"],
    "relatedQuestionIds": ["ace-iam-003", "ace-iam-026"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/understanding-roles#primitive_roles"
  },
  {
    "id": "ace-iam-020",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your organization uses an existing Active Directory for all employee identity management. You want to centrally manage and synchronize these employee accounts to Google Cloud and use their corporate emails to grant them IAM roles via Google Groups.",
    "question": "Which Google Cloud service should you use to establish a unified identity and enable synchronization from your on-premises Active Directory?",
    "options": [
      {
        "id": "A",
        "text": "Workload Identity"
      },
      {
        "id": "B",
        "text": "Identity Platform"
      },
      {
        "id": "C",
        "text": "**Cloud Identity** (or Google Workspace)"
      },
      {
        "id": "D",
        "text": "Cloud KMS"
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "**Cloud Identity** (or Google Workspace) is Google Cloud's Identity as a Service (IDaaS) offering. It acts as the primary identity store for human users and allows synchronization with external identity providers like Active Directory via tools like Google Cloud Directory Sync (GCDS). These synchronized identities are then used to grant IAM roles.",
      "incorrect": {
        "A": "Workload Identity is for *workloads* (e.g., GKE pods, VMs), not human users.",
        "B": "Identity Platform is primarily a customer identity access management (CIAM) solution for consumer-facing apps, not for managing corporate employee identities.",
        "D": "Cloud KMS is for managing encryption keys."
      }
    },
    "keyConceptName": "Cloud Identity for User Management",
    "keyConcept": "Cloud Identity (the fundamental identity service) manages human user accounts (principals) that can be granted IAM roles. It supports enterprise features like SSO and directory synchronization from corporate directories (e.g., Active Directory) via GCDS.",
    "tags": ["iam", "identity", "cloud-identity", "sso", "directory-sync"],
    "examPatternKeywords": [
      "centrally manage and synchronize",
      "employee accounts",
      "Active Directory",
      "Google Groups"
    ],
    "relatedQuestionIds": ["ace-iam-001"],
    "officialDocsUrl": "https://cloud.google.com/identity"
  },
  {
    "id": "ace-iam-021",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your security team requires that access to two specific Cloud Storage buckets, `gs://audit-logs` and `gs://compliance-data`, be restricted to the auditors group, even though developers have the `Storage Object Admin` role on the entire project.",
    "question": "Where should you apply the IAM policy to ensure only the auditors group has access to these two buckets without affecting the project-wide developer permissions?",
    "options": [
      {
        "id": "A",
        "text": "Apply a Custom Role at the Folder level."
      },
      {
        "id": "B",
        "text": "Apply a **separate IAM policy directly to each of the two Cloud Storage buckets**."
      },
      {
        "id": "C",
        "text": "Create a separate project for each bucket."
      },
      {
        "id": "D",
        "text": "Apply an Organization Policy to restrict the bucket visibility."
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "Cloud Storage buckets are one of the key resources in Google Cloud that allow **resource-level IAM policies**. By applying a separate policy directly to the buckets, you can override the inherited project-level policy (for the bucket resource only) and grant permissions only to the auditors group, meeting the requirement for fine-grained control.",
      "incorrect": {
        "A": "Folder-level policies are inherited by all projects and cannot target a specific resource within a project.",
        "C": "Creating a project for each bucket is excessive operational overhead and is not the intended use of resource-level IAM.",
        "D": "Organization Policies enforce constraints across the organization (e.g., location restrictions), but do not manage access control for specific principals on individual buckets."
      }
    },
    "keyConceptName": "Resource-Level IAM",
    "keyConcept": "IAM policies can be applied to certain individual resources, such as Cloud Storage buckets, BigQuery datasets, and GKE nodes. This allows for fine-grained access control that overrides inherited, more permissive policies from higher levels (Project, Folder).",
    "tags": [
      "iam",
      "resource-level",
      "cloud-storage",
      "least-privilege",
      "hierarchy"
    ],
    "examPatternKeywords": [
      "access to two specific Cloud Storage buckets",
      "without affecting the project-wide developer permissions",
      "IAM policy directly to each of the two Cloud Storage buckets"
    ],
    "relatedQuestionIds": ["ace-storage-002"],
    "officialDocsUrl": "https://cloud.google.com/storage/docs/access-control/iam"
  },
  {
    "id": "ace-iam-022",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-choice",
    "scenario": "You are deploying a GKE application that needs to: 1) Read data from a Cloud Storage bucket in a different project (`project-A`). 2) Write logs to Cloud Logging in its own project (`project-B`). The application should have no other permissions.",
    "question": "Following the principle of least privilege, how should you configure the service account for the GKE application?",
    "options": [
      {
        "id": "A",
        "text": "Create one Service Account in `project-B`. Grant it the `roles/storage.objectViewer` role in `project-A`, and the `roles/logging.logWriter` role in `project-B`."
      },
      {
        "id": "B",
        "text": "Create two Service Accounts in `project-B`, one for each task, and use Workload Identity to attach both to the pod."
      },
      {
        "id": "C",
        "text": "Use the default Compute Engine service account and grant it the `roles/editor` role on both projects."
      },
      {
        "id": "D",
        "text": "Create one Service Account in `project-A` and one in `project-B`, then configure trust between the two."
      }
    ],
    "correctAnswer": ["A"],
    "explanation": {
      "correct": "The most efficient and correct method is to create a single **Google Cloud Service Account** in the application's project (`project-B`) and grant it the necessary roles **at the scope where the resource resides**. It needs `storage.objectViewer` in `project-A` (to read the bucket) and `logging.logWriter` in `project-B` (to write logs). This adheres strictly to least privilege and cross-project service account access.",
      "incorrect": {
        "B": "While multiple service accounts can be used, one service account with cross-project roles is generally simpler to manage and sufficient here.",
        "C": "Granting the Editor role violates the principle of least privilege. The default service account is not recommended for production workloads.",
        "D": "Creating the service account in `project-A` to access a resource in `project-B` (Logging) is overly complicated and the reverse of what is needed for the Cloud Storage access."
      }
    },
    "keyConceptName": "Cross-Project Least Privilege",
    "keyConcept": "A single service account can be granted roles in multiple projects. To maintain least privilege, the service account should be granted the minimum required role on the specific resource or project that contains the resource it needs to access.",
    "tags": [
      "iam",
      "least-privilege",
      "cross-project",
      "service-accounts",
      "gke"
    ],
    "examPatternKeywords": [
      "principle of least privilege",
      "read data from a Cloud Storage bucket in a different project",
      "application should have no other permissions"
    ],
    "relatedQuestionIds": ["ace-iam-009", "ace-gke-005"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/service-accounts-access"
  },
  {
    "id": "ace-iam-023",
    "domain": "iam",
    "difficulty": "easy",
    "type": "multiple-choice",
    "scenario": "You have created a custom service account named `data-processor-sa` with the minimum required permissions for your data pipeline. You now need to deploy the pipeline on a new Compute Engine instance.",
    "question": "Which action is the correct, Google-recommended way to provide the Compute Engine instance with the permissions of the `data-processor-sa`?",
    "options": [
      {
        "id": "A",
        "text": "Download the service account key and upload it to the instance as a file."
      },
      {
        "id": "B",
        "text": "Attach the `data-processor-sa` to the instance during creation using the `--service-account` flag."
      },
      {
        "id": "C",
        "text": "Grant the `iam.serviceAccounts.actAs` permission to the instance's default service account."
      },
      {
        "id": "D",
        "text": "Use an Organization Policy to mandate the `data-processor-sa` be used."
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "The recommended method for giving a Compute Engine instance access to GCP resources is to **attach the custom service account** (B) to the instance during its creation. This allows the VM to authenticate via the metadata server and receive short-lived credentials without the need to manage long-lived service account keys.",
      "incorrect": {
        "A": "Downloading keys is insecure and against best practices.",
        "C": "Impersonation (`iam.serviceAccounts.actAs`) is for one service account (or user) to act as another. Attaching the SA directly is simpler and the standard method for a VM's primary identity.",
        "D": "Organization Policies are for setting constraints (e.g., resource location), not for assigning a service account to a VM."
      }
    },
    "keyConceptName": "Attaching Service Accounts to VMs",
    "keyConcept": "Compute Engine instances should be assigned a specific service account during creation. This provides the running workloads with an identity that has access to Google Cloud APIs, using secure, automatically managed short-lived credentials.",
    "tags": ["iam", "service-accounts", "compute-engine", "best-practices"],
    "examPatternKeywords": [
      "correct, Google-recommended way",
      "provide the Compute Engine instance with the permissions"
    ],
    "relatedQuestionIds": ["ace-iam-009", "ace-iam-017"],
    "officialDocsUrl": "https://cloud.google.com/compute/docs/access/create-enable-service-account"
  },
  {
    "id": "ace-iam-024",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "A development team needs to deploy resources using Terraform, but the security policy prevents human users from having direct creation permissions. They must instead use a dedicated service account, `tf-deployer-sa`, for all infrastructure changes.",
    "question": "Which IAM permission should you grant the developers' Google Group to allow them to execute Terraform commands using the permissions of `tf-deployer-sa`?",
    "options": [
      {
        "id": "A",
        "text": "`roles/iam.serviceAccountKeyAdmin` on the `tf-deployer-sa`."
      },
      {
        "id": "B",
        "text": "`roles/editor` on the project."
      },
      {
        "id": "C",
        "text": "`iam.serviceAccounts.actAs` on the `tf-deployer-sa`."
      },
      {
        "id": "D",
        "text": "`roles/iam.serviceAccountUser` on the project."
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "The **`iam.serviceAccounts.actAs`** permission (found within the `Service Account User` role) grants a principal (the developers' Google Group) the ability to **impersonate** a service account (`tf-deployer-sa`). This allows the developers to run `gcloud` or Terraform commands as if they were the service account, using its permissions, without ever needing to see or manage its keys.",
      "incorrect": {
        "A": "This role allows managing keys, which should be avoided. It doesn't enable impersonation.",
        "B": "Editor is too permissive and violates the policy of using a dedicated SA.",
        "D": "`roles/iam.serviceAccountUser` is the **predefined role** that contains `iam.serviceAccounts.actAs`, but the most specific answer is the permission itself, or granting the role on the specific service account (which is what granting the permission does). The most concise and direct action to enable the capability is the permission `iam.serviceAccounts.actAs` on the SA."
      }
    },
    "keyConceptName": "Service Account Impersonation",
    "keyConcept": "Service Account Impersonation (via the `iam.serviceAccounts.actAs` permission) allows a user or a service account to act as another service account. This is the secure, keyless, and recommended way to grant delegated permissions and enable CI/CD pipelines or tool usage.",
    "tags": [
      "iam",
      "service-accounts",
      "impersonation",
      "security",
      "least-privilege"
    ],
    "examPatternKeywords": [
      "human users from having direct creation permissions",
      "use a dedicated service account",
      "execute Terraform commands using the permissions of"
    ],
    "relatedQuestionIds": ["ace-iam-009"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/service-account-impersonation"
  },
  {
    "id": "ace-iam-025",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-choice",
    "scenario": "A security requirement mandates that a specific high-privilege role, `Storage Admin`, can only be used by members of the `security-team-group` when they connect from the corporate network's IP range (`203.0.113.0/24`).",
    "question": "Which IAM feature is required to enforce this conditionality based on the source IP address?",
    "options": [
      {
        "id": "A",
        "text": "VPC Service Controls (VPC SC)"
      },
      {
        "id": "B",
        "text": "Organization Policy Service"
      },
      {
        "id": "C",
        "text": "IAM Policy with a **Condition** based on `request.time`"
      },
      {
        "id": "D",
        "text": "IAM Policy with a **Condition** based on `request.auth.principalIp`"
      }
    ],
    "correctAnswer": ["D"],
    "explanation": {
      "correct": "IAM access can be conditionally granted using **IAM Conditions**. The condition needs to check the source IP address of the request. The correct attribute to use for this is `request.auth.principalIp`, which can be matched against the required CIDR range (`203.0.113.0/24`).",
      "incorrect": {
        "A": "VPC Service Controls restrict access to services, primarily to prevent data exfiltration, but do not provide fine-grained IAM role conditionality based on user IP.",
        "B": "Organization Policies enforce global constraints, not conditional access for a specific role/group/IP combination.",
        "C": "`request.time` allows access to be restricted by time of day (e.g., business hours), not by source IP address."
      }
    },
    "keyConceptName": "IAM Conditions",
    "keyConcept": "IAM Conditions allow you to define and enforce fine-grained, attribute-based access control. They can restrict access based on attributes like the principal's IP address (`request.auth.principalIp`), resource name, resource tags, or time of day (`request.time`).",
    "tags": ["iam", "conditions", "security", "advanced-iam"],
    "examPatternKeywords": [
      "mandates that a specific high-privilege role, Storage Admin, can only be used",
      "connect from the corporate network's IP range",
      "enforce this conditionality"
    ],
    "relatedQuestionIds": ["ace-iam-016"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/conditions-overview"
  },
  {
    "id": "ace-iam-026",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-select",
    "scenario": "A new project was created, and an administrator granted the `Project Owner` role to the default administrator group. This is considered a significant security risk by the security team.",
    "question": "What two inherent risks are associated with granting the `Project Owner` (Primitive) role? (Select TWO)",
    "options": [
      {
        "id": "A",
        "text": "The role grants broad permissions across **all** Google Cloud services in the project."
      },
      {
        "id": "B",
        "text": "The role allows the user to manage **IAM policies** and grant roles to other principals, including themselves."
      },
      {
        "id": "C",
        "text": "The role automatically grants the user access to the billing account, even if not linked to the project."
      },
      {
        "id": "D",
        "text": "The role only provides read-only access, leading to operational delays."
      }
    ],
    "correctAnswer": ["A", "B"],
    "explanation": {
      "correct": "The `Project Owner` role is a Primitive role that grants highly elevated permissions: 1) **Broad Access (A):** It includes all permissions for virtually all services in the project, violating least privilege. 2) **IAM Management (B):** It includes the `resourcemanager.projects.setIamPolicy` permission, allowing the owner to modify all project access and grant the role to anyone.",
      "incorrect": {
        "C": "Access to the billing account is managed by Billing IAM roles, which are separate from Project roles. Ownership of the project does not automatically grant billing admin access.",
        "D": "The Owner role is the most permissive role and includes full read/write/delete access."
      }
    },
    "keyConceptName": "Project Owner Role Risk",
    "keyConcept": "The Project Owner role is the highest privilege project-level role. Its risks include massive scope (all services) and the critical ability to manage IAM policies (grant/revoke any role) and manage billing for the project, making it a target for misuse.",
    "tags": ["iam", "roles", "primitive-roles", "security", "multiple-select"],
    "examPatternKeywords": [
      "significant security risk",
      "inherent risks",
      "Project Owner (Primitive) role"
    ],
    "relatedQuestionIds": ["ace-iam-019"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/understanding-roles#primitive_roles"
  },
  {
    "id": "ace-iam-027",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "You need to enforce a global constraint across all projects in your organization, mandating that only Compute Engine instances with a specific tag (e.g., `environment=production`) can be created. Other instances must be blocked at the creation stage.",
    "question": "Which service should you use to enforce this rule across the entire organization?",
    "options": [
      {
        "id": "A",
        "text": "IAM Deny Policies"
      },
      {
        "id": "B",
        "text": "IAM Role Conditions"
      },
      {
        "id": "C",
        "text": "**Organization Policy Service** with a Constraint"
      },
      {
        "id": "D",
        "text": "VPC Service Controls"
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "The **Organization Policy Service** is designed to centralize and enforce constraints (like required tags, disabled services, or allowed resource locations) across an entire organization, folder, or project hierarchy. You would use a constraint like `constraints/compute.requireInstanceLabel` to mandate the required tag.",
      "incorrect": {
        "A": "IAM Deny Policies block specific *principals* from using a permission, but don't enforce a global rule on *resource configuration* like required tags.",
        "B": "IAM Role Conditions grant access conditionally, but the rule needs to be enforced on resource creation globally, which is the role of Organization Policy.",
        "D": "VPC Service Controls create a security perimeter to prevent data exfiltration and don't enforce resource tags."
      }
    },
    "keyConceptName": "Organization Policy vs. IAM",
    "keyConcept": "The Organization Policy Service manages resource configuration constraints across the GCP hierarchy (e.g., 'must have this tag', 'must be in this region'). IAM manages *who* can do *what* to a resource. Organization Policy acts as a guardrail on *how* resources can be configured.",
    "tags": [
      "iam",
      "organization-policy",
      "security",
      "governance",
      "hierarchy"
    ],
    "examPatternKeywords": [
      "enforce a global constraint across all projects",
      "mandating that only Compute Engine instances with a specific tag",
      "across the entire organization"
    ],
    "relatedQuestionIds": ["ace-iam-016"],
    "officialDocsUrl": "https://cloud.google.com/resource-manager/docs/organization-policy/overview"
  },
  {
    "id": "ace-iam-028",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "A pod in your GKE cluster needs to access a secret stored in Cloud Secret Manager. You want to use the most secure, keyless, and Kubernetes-native method to authenticate the pod to the Google Cloud service.",
    "question": "Which IAM configuration should you use on the GKE cluster to grant this access?",
    "options": [
      {
        "id": "A",
        "text": "Enable Metadata Concealment on the node pool to prevent key exfiltration."
      },
      {
        "id": "B",
        "text": "Grant the `roles/editor` role to the node's service account."
      },
      {
        "id": "C",
        "text": "Configure **Workload Identity** by linking a Kubernetes Service Account to a Google Cloud Service Account with the `Secret Manager Secret Accessor` role."
      },
      {
        "id": "D",
        "text": "Create a Kubernetes Secret containing a downloaded service account key."
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "**Workload Identity** is the recommended, most secure, and keyless way for GKE pods to access Google Cloud services. It establishes a trust relationship between a Kubernetes Service Account (KSA) and a Google Cloud Service Account (GSA) that holds the required permissions (`Secret Manager Secret Accessor` role).",
      "incorrect": {
        "A": "Metadata Concealment is a defense layer but doesn't grant the required permissions.",
        "B": "Granting the Editor role to the node's service account violates the principle of least privilege, giving all pods on that node excessive access.",
        "D": "Managing service account keys in a Kubernetes Secret is insecure and non-recommended."
      }
    },
    "keyConceptName": "Workload Identity (GKE)",
    "keyConcept": "Workload Identity securely grants Google Cloud access to GKE workloads. By mapping a KSA to a GSA, the pod can exchange its identity for an access token without needing to store or manage long-lived service account keys.",
    "tags": ["iam", "workload-identity", "gke", "security", "best-practices"],
    "examPatternKeywords": [
      "most secure",
      "keyless",
      "Kubernetes-native method",
      "authenticate the pod"
    ],
    "relatedQuestionIds": ["ace-gke-005"],
    "officialDocsUrl": "https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity"
  },
  {
    "id": "ace-iam-029",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your application stores user-uploaded files in a Cloud Storage bucket. You need to configure the bucket so that the `frontend-service-sa` service account can only upload new objects, but cannot delete or overwrite existing objects.",
    "question": "Which Google-predefined role provides the minimum necessary permission to fulfill the requirement of only uploading new objects to a Cloud Storage bucket?",
    "options": [
      {
        "id": "A",
        "text": "`Storage Object Admin`"
      },
      {
        "id": "B",
        "text": "`Storage Object Viewer`"
      },
      {
        "id": "C",
        "text": "`Storage Object Creator`"
      },
      {
        "id": "D",
        "text": "`Storage Admin`"
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "The `Storage Object Creator` role grants the necessary `storage.objects.create` permission, allowing the service account to upload new objects to a bucket. It does *not* include the permissions to read (`storage.objects.get`) or delete (`storage.objects.delete`), adhering to the principle of least privilege for the 'upload-only' requirement.",
      "incorrect": {
        "A": "Storage Object Admin grants full control over objects, including delete and overwrite, which violates the requirement.",
        "B": "Storage Object Viewer is read-only and cannot upload new objects.",
        "D": "Storage Admin grants full control over the bucket *metadata* and access control, not just the objects, and is overly permissive."
      }
    },
    "keyConceptName": "Cloud Storage Predefined Roles",
    "keyConcept": "Cloud Storage provides granular predefined roles for object-level access: `Object Viewer` (read), `Object Creator` (write/upload new), and `Object Admin` (read/write/delete). Selecting the correct one ensures least privilege.",
    "tags": ["iam", "cloud-storage", "roles", "least-privilege"],
    "examPatternKeywords": [
      "minimum necessary permission",
      "only upload new objects",
      "cannot delete or overwrite"
    ],
    "relatedQuestionIds": ["ace-storage-002"],
    "officialDocsUrl": "https://cloud.google.com/storage/docs/access-control/iam#predefined-roles"
  },
  {
    "id": "ace-iam-030",
    "domain": "iam",
    "difficulty": "easy",
    "type": "multiple-choice",
    "scenario": "Your organization has over 50 projects and hundreds of developers. You need to streamline the process of granting access to these projects by managing access for teams rather than individuals.",
    "question": "Which type of principal should you use as the recommended best practice for assigning IAM roles to groups of human users?",
    "options": [
      {
        "id": "A",
        "text": "Individual user accounts"
      },
      {
        "id": "B",
        "text": "**Google Groups**"
      },
      {
        "id": "C",
        "text": "Service accounts"
      },
      {
        "id": "D",
        "text": "API keys"
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "Using **Google Groups** (A `group:email@domain.com` principal) is the Google-recommended best practice for managing access for multiple human users. It simplifies user lifecycle management (onboarding/offboarding) and centralizes role management, as you only need to update the group's membership, not every user's IAM binding.",
      "incorrect": {
        "A": "Managing individual user accounts is cumbersome and error-prone at scale.",
        "C": "Service accounts are for non-human workloads/applications, not groups of human users.",
        "D": "API keys are simple access tokens for specific services and are not used as principals for IAM role binding."
      }
    },
    "keyConceptName": "Google Groups for IAM Management",
    "keyConcept": "Google Groups is the preferred mechanism for applying IAM roles to human users. This decouples user lifecycle management from permission management, improving scalability, auditability, and adherence to security policies.",
    "tags": [
      "iam",
      "identity",
      "google-groups",
      "best-practices",
      "governance"
    ],
    "examPatternKeywords": [
      "streamline the process of granting access",
      "managing access for teams rather than individuals",
      "recommended best practice"
    ],
    "relatedQuestionIds": ["ace-iam-001"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/best-practices-for-using-groups"
  },

  {
    "id": "ace-iam-031",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-select",
    "scenario": "A security audit requires that any service account key created in your 'Production' project must be rotated (deleted and replaced) within 90 days. You want to implement a mechanism that automatically enforces the deletion of old, long-lived keys for all service accounts in the project.",
    "question": "Which two actions are necessary to implement the automatic enforcement of the 90-day service account key rotation policy in your project? (Select TWO)",
    "options": [
      {
        "id": "A",
        "text": "Use the Cloud Asset Inventory to monitor the key creation date."
      },
      {
        "id": "B",
        "text": "Configure an **IAM policy condition** using `request.time` to block access after 90 days."
      },
      {
        "id": "C",
        "text": "Configure a **Cloud Function** triggered by **Cloud Audit Logs** for key creation events."
      },
      {
        "id": "D",
        "text": "Implement a **custom script or Cron Job** that calls the `gcloud iam service-accounts keys delete` command for keys older than 90 days."
      }
    ],
    "correctAnswer": ["C", "D"],
    "explanation": {
      "correct": "IAM does not have a built-in auto-deletion mechanism based on key age. The standard automated solution involves: 1) A **custom script/Cron Job (D)** running on a schedule to list all keys in the project and use the `gcloud` or API calls to delete those older than 90 days. 2) Alternatively, a more real-time approach is a **Cloud Function (C)** triggered by **Cloud Audit Logs** (specifically, the `google.iam.admin.v1.CreateServiceAccountKey` event) that could start a key rotation/deletion workflow, though the scheduled script (D) is the most direct way to check for *old* keys.",
      "incorrect": {
        "A": "Cloud Asset Inventory is for inventory, not for triggering actions or enforcing policy deletion.",
        "B": "IAM policy conditions using `request.time` can block *usage* after a certain time, but they do not automatically *delete* the key, leaving the long-lived credential intact."
      }
    },
    "keyConceptName": "Automated Service Account Key Rotation",
    "keyConcept": "Enforcing key rotation requires an external, automated mechanism, as Google Cloud IAM does not automatically delete service account keys by age. This is typically implemented via scheduled automation scripts or Cloud Functions triggered by Audit Logs to enforce policy and delete keys that exceed the age limit.",
    "tags": [
      "iam",
      "service-accounts",
      "security",
      "automation",
      "best-practices",
      "multiple-select"
    ],
    "examPatternKeywords": [
      "service account key created",
      "rotated within 90 days",
      "automatically enforces the deletion"
    ],
    "relatedQuestionIds": ["ace-iam-017", "ace-iam-009"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/best-practices-service-accounts#automated_key_rotation"
  },
  {
    "id": "ace-iam-032",
    "domain": "iam",
    "difficulty": "easy",
    "type": "multiple-choice",
    "scenario": "You are integrating an on-premises application with a Cloud Storage bucket in your Google Cloud project. The application cannot use Workload Identity or the metadata server and requires a static credential file to authenticate.",
    "question": "Which type of credential is required for a third-party application running outside of Google Cloud to authenticate as a Service Account?",
    "options": [
      {
        "id": "A",
        "text": "OAuth 2.0 Client ID"
      },
      {
        "id": "B",
        "text": "API Key"
      },
      {
        "id": "C",
        "text": "**Service Account Key** (JSON or P12 file)"
      },
      {
        "id": "D",
        "text": "Cloud Identity User Credential"
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "For workloads running **outside of Google Cloud** (e.g., on-premises, a different cloud, or a CI/CD system) that cannot use mechanisms like Workload Identity or external identity federation, a **Service Account Key** (a JSON or P12 private key file) is the necessary credential to authenticate as the service account.",
      "incorrect": {
        "A": "Client IDs are typically used for user-facing applications requiring user consent (OAuth).",
        "B": "API Keys are simple access tokens for specific APIs and do not carry the identity or roles of a service account.",
        "D": "Cloud Identity User Credentials are for human users, not applications."
      }
    },
    "keyConceptName": "External Service Account Authentication",
    "keyConcept": "While Service Account Keys should be avoided for workloads *within* GCP, they are the standard authentication mechanism for external or third-party applications that need to authenticate as a GCP Service Account.",
    "tags": ["iam", "service-accounts", "authentication", "on-premises"],
    "examPatternKeywords": [
      "on-premises application",
      "outside of Google Cloud",
      "requires a static credential file",
      "authenticate as a Service Account"
    ],
    "relatedQuestionIds": ["ace-iam-023"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/creating-managing-service-account-keys"
  },
  {
    "id": "ace-iam-033",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "You have a Google Cloud Project with a complex set of IAM policies applied at the Folder and Project levels. You are investigating why a specific user, `user:alice@example.com`, has the permission `compute.instances.create` despite having no explicit binding to a Compute role at the Project level.",
    "question": "What is the most likely reason Alice has this permission?",
    "options": [
      {
        "id": "A",
        "text": "Alice is implicitly granted all permissions because she is the Project Creator."
      },
      {
        "id": "B",
        "text": "Alice has the `iam.serviceAccounts.actAs` permission on the Compute Engine Service Account."
      },
      {
        "id": "C",
        "text": "Alice is a member of a **Google Group** that has been granted a role containing `compute.instances.create` at the **Folder or Organization level**."
      },
      {
        "id": "D",
        "text": "Alice is a member of the project's **Billing Administrator** role."
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "IAM permissions are **inherited hierarchically**. The most likely source of an unexpected permission at the Project level is an inherited role binding from a higher level (**Folder or Organization**). The best practice is to assign roles to **Google Groups** (C), meaning Alice is likely a member of a group that received a permissive role (like Editor or a custom role) at a higher level.",
      "incorrect": {
        "A": "The Project Creator is automatically granted the `Owner` role, but this role is an *explicit* binding and not 'implicit.' If she was the Owner, that role would be visible in the Project policy.",
        "B": "`actAs` allows impersonation, not the direct usage of a permission like `compute.instances.create` for herself.",
        "D": "Billing Administrator roles manage billing and do not grant compute resource creation permissions."
      }
    },
    "keyConceptName": "IAM Policy Inheritance and Audit",
    "keyConcept": "IAM policies are inherited down the resource hierarchy (Organization > Folder > Project > Resource). When investigating unexpected permissions, you must check the effective policy by inspecting bindings at all ancestor levels. Group membership is a common source of inherited permissions.",
    "tags": [
      "iam",
      "inheritance",
      "troubleshooting",
      "hierarchy",
      "google-groups"
    ],
    "examPatternKeywords": [
      "investigating why a specific user",
      "no explicit binding at the Project level",
      "most likely reason"
    ],
    "relatedQuestionIds": ["ace-iam-007", "ace-iam-016"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/overview#policy_inheritance"
  },
  {
    "id": "ace-iam-034",
    "domain": "iam",
    "difficulty": "hard",
    "type": "multiple-choice",
    "scenario": "Your security team requires that access to the `Secret Manager` in the 'Production' project must be audited, and access should only be granted during business hours (9 AM to 5 PM EST) on weekdays.",
    "question": "How should you enforce this time-bound access for a specific group of users, `dev-access@example.com`?",
    "options": [
      {
        "id": "A",
        "text": "Use an **IAM Policy Condition** on the binding for `dev-access@example.com` using the **`request.time`** attribute."
      },
      {
        "id": "B",
        "text": "Create a scheduled Cloud Function to manually remove the role binding at 5 PM and re-add it at 9 AM."
      },
      {
        "id": "C",
        "text": "Enable VPC Service Controls to restrict access based on network."
      },
      {
        "id": "D",
        "text": "Use an Organization Policy to restrict the access time globally."
      }
    ],
    "correctAnswer": ["A"],
    "explanation": {
      "correct": "The most effective and declarative way to enforce time-bound access in IAM is by using an **IAM Policy Condition (A)**. The condition can target the `request.time` attribute (e.g., `request.time.day_of_week in ['MON', 'TUE', 'WED', 'THU', 'FRI'] && request.time.is_between('09:00:00', '17:00:00', 'America/New_York')`) on the role binding for the specified group.",
      "incorrect": {
        "B": "Manual role management via scripts is complex, brittle, and not the recommended declarative approach.",
        "C": "VPC Service Controls protect data exfiltration based on network perimeter, not on time of day.",
        "D": "Organization Policies enforce global resource constraints, not conditional access for a specific role/group based on time."
      }
    },
    "keyConceptName": "IAM Conditions (Time-Based)",
    "keyConcept": "IAM Conditions provide Attribute-Based Access Control (ABAC). They allow you to add fine-grained constraints to IAM policies, including time-of-day restrictions using the `request.time` attribute, which is ideal for enforcing scheduled access for highly sensitive resources.",
    "tags": ["iam", "conditions", "security", "time-based", "advanced-iam"],
    "examPatternKeywords": [
      "time-bound access",
      "9 AM to 5 PM EST on weekdays",
      "enforce this conditionality"
    ],
    "relatedQuestionIds": ["ace-iam-025"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/conditions-reference#time"
  },
  {
    "id": "ace-iam-035",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "You are preparing a Compute Engine instance to run a scheduled data processing job. The job only needs to write data to a specific BigQuery dataset, `project-id:dataset-name`, and nothing else. You want to adhere strictly to the principle of least privilege.",
    "question": "Which set of steps should you follow to correctly provision the service account and the Compute Engine instance?",
    "options": [
      {
        "id": "A",
        "text": "Use the default Compute Engine service account and set the instance access scope to BigQuery."
      },
      {
        "id": "B",
        "text": "Create a Custom Role with the `bigquery.datasets.get` and `bigquery.tables.updateData` permissions, and grant this role to the instance's default service account."
      },
      {
        "id": "C",
        "text": "Create a custom Service Account, grant it the **`BigQuery Data Editor`** role, and **attach it to the VM** during creation."
      },
      {
        "id": "D",
        "text": "Create a custom Service Account, grant it the `BigQuery Data Editor` role, and apply this role to the **specific BigQuery Dataset** instead of the project."
      }
    ],
    "correctAnswer": ["D"],
    "explanation": {
      "correct": "This question tests the lowest level of least privilege. The correct approach is: 1) Create a **custom Service Account**. 2) Grant it the `BigQuery Data Editor` role (which allows writing). 3) Apply this binding **only to the specific dataset (D)**, not the entire project, to scope the access precisely. 4) **Attach the SA to the VM** (implied by the process of using an SA for a VM). Applying the role at the dataset level ensures the SA cannot write to *other* datasets in the project.",
      "incorrect": {
        "A": "Default SA and instance access scopes are too broad and violate least privilege.",
        "B": "Granting a custom role to the *default* service account is still bad practice, and the scope is the whole project, not the single dataset.",
        "C": "This is a good step, but applying the role at the project level is less granular than applying it directly to the dataset, which is the tighter constraint available for BigQuery."
      }
    },
    "keyConceptName": "Resource-Level IAM and Least Privilege",
    "keyConcept": "For services that support resource-level IAM (like BigQuery Datasets), you should apply roles at the resource level rather than the project level to minimize the scope of access and strictly adhere to the principle of least privilege.",
    "tags": [
      "iam",
      "least-privilege",
      "bigquery",
      "service-accounts",
      "resource-level"
    ],
    "examPatternKeywords": [
      "only needs to write data to a specific BigQuery dataset",
      "nothing else",
      "adhere strictly to the principle of least privilege"
    ],
    "relatedQuestionIds": ["ace-iam-021"],
    "officialDocsUrl": "https://cloud.google.com/bigquery/docs/access-control"
  },
  {
    "id": "ace-iam-036",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your organization uses a CI/CD pipeline running in a different cloud provider (AWS) and needs to deploy resources into your Google Cloud 'Staging' project. You want to enable this cross-cloud access without creating and managing long-lived service account keys.",
    "question": "Which IAM feature enables external identities (like an AWS role) to assume the identity of a Google Cloud Service Account securely and without keys?",
    "options": [
      {
        "id": "A",
        "text": "VPC Service Controls"
      },
      {
        "id": "B",
        "text": "Cloud Identity for Users"
      },
      {
        "id": "C",
        "text": "**Workload Identity Federation**"
      },
      {
        "id": "D",
        "text": "Service Account Key Impersonation"
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "**Workload Identity Federation** is the feature that allows a workload running outside of Google Cloud (e.g., an AWS role, a GitHub Actions runner, or an Azure service principal) to directly exchange its own short-lived token for a short-lived Google Cloud Service Account token, enabling keyless, cross-cloud authentication.",
      "incorrect": {
        "A": "VPC Service Controls prevent data exfiltration and are unrelated to cross-cloud authentication.",
        "B": "Cloud Identity is for human user management.",
        "D": "While service account impersonation is used, the mechanism that allows the *external* identity to perform the impersonation is Workload Identity Federation, which eliminates the need for service account keys."
      }
    },
    "keyConceptName": "Workload Identity Federation",
    "keyConcept": "Workload Identity Federation extends the Workload Identity concept to external platforms. It allows workloads in other environments to authenticate to Google Cloud as a Service Account without requiring a service account key, improving security for multi-cloud and hybrid environments.",
    "tags": [
      "iam",
      "workload-identity-federation",
      "security",
      "multi-cloud",
      "ci-cd"
    ],
    "examPatternKeywords": [
      "CI/CD pipeline running in a different cloud provider (AWS)",
      "deploy resources into your Google Cloud",
      "without creating and managing long-lived service account keys"
    ],
    "relatedQuestionIds": ["ace-iam-028"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/workload-identity-federation"
  },
  {
    "id": "ace-iam-037",
    "domain": "iam",
    "difficulty": "easy",
    "type": "multiple-choice",
    "scenario": "You need to create a new Service Account for a background application. You want to ensure the name of the Service Account clearly identifies its purpose and the project it belongs to.",
    "question": "What is the correct format for referencing a Service Account email address in an IAM policy binding?",
    "options": [
      {
        "id": "A",
        "text": "user:account-name@project-id.iam.gserviceaccount.com"
      },
      {
        "id": "B",
        "text": "principal:account-name@project-id.iam.gserviceaccount.com"
      },
      {
        "id": "C",
        "text": "**serviceAccount:account-name@project-id.iam.gserviceaccount.com**"
      },
      {
        "id": "D",
        "text": "group:account-name@project-id.iam.gserviceaccount.com"
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "The correct format for referencing a Service Account as a **principal** in an IAM policy is to use the prefix **`serviceAccount:`** followed by the full Service Account email address, which ends in `.gserviceaccount.com`.",
      "incorrect": {
        "A": "`user:` is used for individual human users.",
        "B": "`principal:` is a generic term but not the specific prefix used in IAM policy bindings.",
        "D": "`group:` is used for Google Groups, which are for human users, not service accounts."
      }
    },
    "keyConceptName": "IAM Principal Types (Service Account)",
    "keyConcept": "IAM policies use prefixes to define the type of principal being granted access. Common prefixes include `user:`, `group:`, `serviceAccount:`, and `domain:`.",
    "tags": ["iam", "service-accounts", "principals", "syntax"],
    "examPatternKeywords": [
      "correct format for referencing a Service Account",
      "IAM policy binding"
    ],
    "relatedQuestionIds": ["ace-iam-030"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/overview#principals"
  },
  {
    "id": "ace-iam-038",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "You are creating a highly restrictive custom role for a data viewer. You want the user to be able to read data from all BigQuery tables but explicitly need to **prevent** them from viewing the contents of two specific, sensitive columns in a table called `users.PII`.",
    "question": "Which IAM feature must you use to enforce column-level access control within BigQuery?",
    "options": [
      {
        "id": "A",
        "text": "BigQuery Row-Level Security Policies"
      },
      {
        "id": "B",
        "text": "A standard Custom IAM Role with a Deny Policy."
      },
      {
        "id": "C",
        "text": "BigQuery **Column-Level Security (Data Masking)**, combined with an IAM role."
      },
      {
        "id": "D",
        "text": "VPC Service Controls."
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "IAM provides access control at the resource level (dataset, table), but **Column-Level Security (Data Masking)** is the BigQuery-specific feature required to control access to specific columns or obfuscate their data. This involves setting an IAM policy on a **Tag/Taxonomy** that is applied to the sensitive columns, which then requires the user to have a corresponding role (like `roles/datacatalog.maskedReader`) to see the unmasked data.",
      "incorrect": {
        "A": "Row-Level Security restricts *rows* of data (e.g., 'only see your own data'), not specific columns.",
        "B": "Standard IAM roles and Deny policies work at the service/resource level, not the column level.",
        "D": "VPC Service Controls protect the boundary of the service, not internal data fields."
      }
    },
    "keyConceptName": "BigQuery Column-Level Security",
    "keyConcept": "Column-Level Security in BigQuery, often implemented via Data Masking and IAM policy tags, allows you to grant or restrict access to data within specific table columns, providing highly granular data governance that standard IAM cannot achieve alone.",
    "tags": ["iam", "bigquery", "data-governance", "security", "column-level"],
    "examPatternKeywords": [
      "highly restrictive custom role",
      "prevent them from viewing the contents of two specific, sensitive columns",
      "column-level access control"
    ],
    "relatedQuestionIds": ["ace-iam-021", "ace-data-analytics-005"],
    "officialDocsUrl": "https://cloud.google.com/bigquery/docs/column-level-security"
  },
  {
    "id": "ace-iam-039",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "A development team wants to create and manage the configuration of a specific `Dataproc` cluster for their data science workloads. They should have full control over the cluster lifecycle but must be **prevented** from granting *any* IAM roles or managing other infrastructure.",
    "question": "Which set of IAM roles is the best combination to grant the developers full control over their Dataproc clusters while adhering to the principle of least privilege?",
    "options": [
      {
        "id": "A",
        "text": "Project Owner role"
      },
      {
        "id": "B",
        "text": "`Dataproc Administrator` role and the `roles/iam.serviceAccountUser` role."
      },
      {
        "id": "C",
        "text": "`Compute Instance Admin (v1)` role and `Dataproc Worker` role."
      },
      {
        "id": "D",
        "text": "A **Custom Role** with only the necessary Dataproc permissions and a **Deny Policy** on `resourcemanager.projects.setIamPolicy`."
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "The **`Dataproc Administrator`** role (`roles/dataproc.admin`) provides full management of Dataproc clusters. Because Dataproc clusters launch Compute Engine instances and use a Service Account to perform tasks, the user also needs permission to use (impersonate) the cluster's Service Account, which is provided by the **`roles/iam.serviceAccountUser`** role. This combination grants full cluster control without IAM policy management permissions.",
      "incorrect": {
        "A": "Project Owner grants all permissions, including IAM management, violating the security requirement.",
        "C": "`Dataproc Worker` is for the cluster's Service Account, not the human administrator. `Compute Admin` is not needed if using the Dataproc roles.",
        "D": "While a Custom Role *could* be used, the `Dataproc Administrator` predefined role already provides the necessary control without IAM permissions, making it the most practical least-privilege choice. A Deny Policy isn't typically needed to prevent `setIamPolicy` if the role itself doesn't contain it."
      }
    },
    "keyConceptName": "Dataproc IAM Roles",
    "keyConcept": "Dataproc roles (`Admin`, `Editor`, `Viewer`) govern cluster lifecycle management. When a human user is granted an admin role, they often also need the ability to use the cluster's underlying Service Account, granted via the `Service Account User` role, to successfully create the cluster's VMs.",
    "tags": ["iam", "least-privilege", "dataproc", "service-accounts"],
    "examPatternKeywords": [
      "full control over the cluster lifecycle",
      "prevented from granting any IAM roles",
      "least privilege"
    ],
    "officialDocsUrl": "https://cloud.google.com/dataproc/docs/concepts/iam/dataproc-iam"
  },
  {
    "id": "ace-iam-040",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "Your organization uses a single VPC network (`shared-vpc-host`) hosted in a separate project. You are creating a GKE cluster in a service project and need to connect it to a subnet in the host project.",
    "question": "Which IAM role is required by the GKE Service Account (the service agent of the service project) on the Shared VPC **host project** to enable cluster creation?",
    "options": [
      {
        "id": "A",
        "text": "`roles/editor`"
      },
      {
        "id": "B",
        "text": "`roles/compute.networkViewer`"
      },
      {
        "id": "C",
        "text": "**`roles/compute.networkUser`**"
      },
      {
        "id": "D",
        "text": "`roles/serviceusage.serviceUsageAdmin`"
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "The GKE service agent from the service project needs the **`roles/compute.networkUser`** role on the Shared VPC host project. This role grants the service account the necessary permission (`compute.networks.use`) to create and manage resources (like GKE nodes and firewall rules) within the host project's network without giving it full administrative control over the network configuration.",
      "incorrect": {
        "A": "Editor is too permissive and violates least privilege.",
        "B": "Network Viewer is read-only and cannot create resources in the network.",
        "D": "Service Usage Admin manages API enablement, which is irrelevant to network resource utilization."
      }
    },
    "keyConceptName": "GKE Shared VPC IAM",
    "keyConcept": "For GKE in a Shared VPC environment, the GKE Service Agent (Service Project) must have the `Compute Network User` role on the Host Project to use the shared network resources for provisioning nodes and configuring network elements.",
    "tags": ["iam", "networking", "shared-vpc", "gke", "service-accounts"],
    "examPatternKeywords": [
      "Shared VPC host project",
      "GKE cluster in a service project",
      "IAM role is required by the GKE Service Account"
    ],
    "relatedQuestionIds": ["ace-gke-021"],
    "officialDocsUrl": "https://cloud.google.com/kubernetes-engine/docs/how-to/shared-vpc#service_project_iam"
  },
  {
    "id": "ace-iam-041",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "A new developer needs temporary access to deploy and test an application on Cloud Run in the 'Staging' project. This access should be valid for exactly 24 hours, and then automatically revoked.",
    "question": "How can you grant the developer the necessary role (`roles/run.developer`) with an automatic expiration time?",
    "options": [
      {
        "id": "A",
        "text": "Use an Organization Policy to set a role binding lifetime limit."
      },
      {
        "id": "B",
        "text": "Apply a **conditional IAM binding** using the `request.time` attribute to block access after 24 hours."
      },
      {
        "id": "C",
        "text": "Use the **`gcloud projects add-iam-policy-binding` command** with the **`--condition` and `request.time.expires`** to set a time-bound role."
      },
      {
        "id": "D",
        "text": "Create a service account key that expires in 24 hours and ask the developer to use it."
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "You can use the **`gcloud` command with a condition** to create a role binding that **expires** automatically. The `request.time.expires` attribute defines the absolute time after which the role binding is no longer valid, achieving the time-bound access requirement declaratively and securely.",
      "incorrect": {
        "A": "Organization Policies set global constraints, not role binding lifetimes for individuals.",
        "B": "A simple `request.time` condition can only check the time of day, not calculate a 24-hour duration from the grant time. The `expires` function is necessary.",
        "D": "Service account keys are for workloads, not human users. Also, setting a key expiration doesn't revoke the underlying user's role."
      }
    },
    "keyConceptName": "Time-Bound IAM Role Bindings",
    "keyConcept": "IAM Conditions can be used to set an **expiration date** on a role binding for a specific principal. This is ideal for managing temporary access for human users (contractors, temporary staff, etc.), ensuring the principle of time-based least privilege.",
    "tags": ["iam", "conditions", "temporary-access", "security"],
    "examPatternKeywords": [
      "temporary access",
      "valid for exactly 24 hours",
      "automatically revoked"
    ],
    "relatedQuestionIds": ["ace-iam-025", "ace-iam-034"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/role-bindings-conditions"
  },
  {
    "id": "ace-iam-042",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-select",
    "scenario": "You are creating a new custom IAM role for a security analyst. The analyst needs to see all resource metadata and IAM policies across the project but should be prevented from viewing the contents of any sensitive data (e.g., Cloud Storage objects, BigQuery tables).",
    "question": "Which two minimum required permissions should you include in the custom role to meet this requirement? (Select TWO)",
    "options": [
      {
        "id": "A",
        "text": "`roles/viewer`"
      },
      {
        "id": "B",
        "text": "**`resourcemanager.projects.getIamPolicy`**"
      },
      {
        "id": "C",
        "text": "**`*.*.list`** (all list permissions)"
      },
      {
        "id": "D",
        "text": "`storage.objects.get`"
      }
    ],
    "correctAnswer": ["B", "C"],
    "explanation": {
      "correct": "1) To see all IAM policies, the analyst needs the **`resourcemanager.projects.getIamPolicy` (B)** permission. 2) To see all resource metadata and listings (e.g., list all VMs, list all buckets, list all tables) without accessing the data contents, the analyst needs all **`*.*.list` (C)** permissions across all services. This combination grants full metadata and policy visibility without granting data-level read access (`*.get`).",
      "incorrect": {
        "A": "`roles/viewer` is a predefined role and is often too broad; the custom role approach is more precise, and it may contain unnecessary `*.get` permissions for small objects.",
        "D": "`storage.objects.get` allows viewing the *content* of an object, which violates the requirement to prevent viewing sensitive data."
      }
    },
    "keyConceptName": "Custom Role Permissions (Metadata vs. Data)",
    "keyConcept": "In IAM, permissions ending in `list` or `get` often retrieve metadata, while permissions like `get` or `read` on a data resource (e.g., `storage.objects.get`) retrieve the actual content. A security role often combines metadata access with IAM policy viewing.",
    "tags": [
      "iam",
      "custom-roles",
      "least-privilege",
      "security",
      "multiple-select"
    ],
    "examPatternKeywords": [
      "see all resource metadata and IAM policies",
      "prevented from viewing the contents of any sensitive data",
      "minimum required permissions"
    ],
    "relatedQuestionIds": ["ace-iam-018"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/understanding-roles"
  },
  {
    "id": "ace-iam-043",
    "domain": "iam",
    "difficulty": "easy",
    "type": "multiple-choice",
    "scenario": "You need to determine the final, effective set of permissions a user has on a specific Compute Engine instance. The user has roles granted at the Organization, Folder, and Project levels, and is also a member of two different Google Groups, each with its own role bindings.",
    "question": "How are the final permissions for the user determined in Google Cloud IAM?",
    "options": [
      {
        "id": "A",
        "text": "The permissions are determined solely by the highest-level role granted at the Organization level."
      },
      {
        "id": "B",
        "text": "Permissions are determined by the most restrictive role explicitly granted at the resource level."
      },
      {
        "id": "C",
        "text": "The **final permissions are the union (sum) of all permissions granted** via all roles, at all levels (Organization, Folder, Project, Resource), and through all group memberships."
      },
      {
        "id": "D",
        "text": "Permissions are inherited but only the explicit role binding at the Project level is considered."
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "Google Cloud IAM follows the principle of **'additive' permissions**. The **final effective permissions (C)** for a principal on any given resource are the **union (sum)** of all individual permissions granted by all roles received through any channel (direct binding, Google Group membership, Service Account Impersonation) and at any level in the resource hierarchy (Organization, Folder, Project, Resource).",
      "incorrect": {
        "A": "This ignores all lower-level and group-based roles.",
        "B": "IAM permissions are additive, not restrictive or subtractive (unless a Deny Policy is used).",
        "D": "This ignores inheritance from the hierarchy and group memberships."
      }
    },
    "keyConceptName": "IAM Policy Evaluation (Additive)",
    "keyConcept": "IAM policy evaluation is additive (union). A principal's effective permissions are the sum of all permissions granted to them, their groups, and any inherited roles, with an explicit Deny policy being the only exception that blocks access.",
    "tags": ["iam", "hierarchy", "policy-evaluation", "additive"],
    "examPatternKeywords": [
      "determine the final, effective set of permissions",
      "all levels and groups",
      "how are the final permissions for the user determined"
    ],
    "relatedQuestionIds": ["ace-iam-007", "ace-iam-033"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/overview#policy_evaluation"
  },
  {
    "id": "ace-iam-044",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "You are debugging an access issue where a user is being denied access to a Cloud Storage bucket. You have already verified the user is in the correct Google Group and that the group has the correct `Storage Object Viewer` role on the bucket.",
    "question": "Which specific tool or feature in the GCP Console should you use to check the final, effective permissions of the user on the specific bucket and identify the exact permission that is missing or being denied?",
    "options": [
      {
        "id": "A",
        "text": "Cloud Audit Logs, filtering for DENY messages."
      },
      {
        "id": "B",
        "text": "The **IAM Policy Troubleshooter**"
      },
      {
        "id": "C",
        "text": "The Project-level IAM page."
      },
      {
        "id": "D",
        "text": "The Resource Manager Hierarchy Viewer."
      }
    ],
    "correctAnswer": ["B"],
    "explanation": {
      "correct": "The **IAM Policy Troubleshooter (B)** is the Google-recommended and most effective tool for diagnosing access issues. You input the principal (user), the resource, and the permission they are trying to use, and the Troubleshooter returns an explanation of whether the access is 'ALLOWED' or 'DENIED', and which policy binding (or lack thereof) is the root cause.",
      "incorrect": {
        "A": "Audit Logs show past actions and denials, but the Troubleshooter provides a proactive diagnosis of the policy itself.",
        "C": "The Project-level page shows only project bindings, not the effective policy on a specific resource (bucket) which is likely inheriting or being overridden.",
        "D": "Hierarchy Viewer shows the policy inheritance path but doesn't perform the final permission calculation."
      }
    },
    "keyConceptName": "IAM Policy Troubleshooting",
    "keyConcept": "The IAM Policy Troubleshooter is a diagnostic tool that helps users understand why a principal has or does not have a specific permission on a specific resource, analyzing the complete policy hierarchy and group memberships.",
    "tags": ["iam", "troubleshooting", "iam-troubleshooter"],
    "examPatternKeywords": [
      "debugging an access issue",
      "check the final, effective permissions",
      "identify the exact permission that is missing or being denied"
    ],
    "relatedQuestionIds": ["ace-iam-033"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/troubleshooter-overview"
  },
  {
    "id": "ace-iam-045",
    "domain": "iam",
    "difficulty": "medium",
    "type": "multiple-choice",
    "scenario": "You need to delegate the ability to create and manage service accounts to a new CI/CD administrator. The administrator should only have control over service accounts and their keys, and no other permissions.",
    "question": "Which single predefined IAM role should you grant the CI/CD administrator to satisfy this requirement of managing service accounts and their keys?",
    "options": [
      {
        "id": "A",
        "text": "`roles/iam.serviceAccountUser`"
      },
      {
        "id": "B",
        "text": "`roles/editor`"
      },
      {
        "id": "C",
        "text": "**`roles/iam.serviceAccountAdmin`**"
      },
      {
        "id": "D",
        "text": "`roles/serviceusage.serviceUsageAdmin`"
      }
    ],
    "correctAnswer": ["C"],
    "explanation": {
      "correct": "The **`Service Account Admin`** role (`roles/iam.serviceAccountAdmin`) grants permissions to create, delete, and update service accounts, as well as manage their keys. This is the correct, least-privilege role for the administration of service accounts, without granting broader project permissions.",
      "incorrect": {
        "A": "`Service Account User` only allows a user to impersonate or attach a service account to a resource, not manage the service account itself.",
        "B": "Editor is too permissive and grants access to many non-IAM services.",
        "D": "Service Usage Admin manages API enablement."
      }
    },
    "keyConceptName": "Service Account Administrative Roles",
    "keyConcept": "The `Service Account Admin` role is specifically designed for users who need to manage the service accounts themselves (create, delete, key management), separate from those who merely need to *use* them (`Service Account User`).",
    "tags": ["iam", "service-accounts", "roles", "least-privilege"],
    "examPatternKeywords": [
      "delegate the ability to create and manage service accounts",
      "only have control over service accounts and their keys",
      "single predefined IAM role"
    ],
    "relatedQuestionIds": ["ace-iam-009"],
    "officialDocsUrl": "https://cloud.google.com/iam/docs/understanding-roles#service-account-roles"
  }
]
